package util;

import java.util.Collection;
import java.util.Iterator;
import java.util.Random;
import java.util.RandomAccess;
import java.util.function.Consumer;
import java.util.stream.Stream;

/**
 * An interface representing a generatable collection of elements of type T.
 * This interface extends {@link Iterable} to allow iteration over the generated elements.
 * The generator is expected to produce an infinite sequence of elements.
 * <p>
 * Together with {@link Generator}, this interface can be used to create custom generators
 * that can be used in enhanced for-loops, therefore providing a simple way to generate
 * sequences of values on-the-fly.
 * For example, given some generator that produce integers:
 * <pre>{@code
 *     Generatable<Integer> intGen = ...; // some generator that produces integers
 *     for (int i : intGen) {
 *         System.out.println(i); // Or do something else with the generated integer
 *         // This will print integers indefinitely
 *     }
 * }</pre>
 * <p>
 * It is not recommended to case this interface to {@link Iterable} directly, as it may lead
 * to confusion since the generator is infinite and will not terminate.
 * <p>
 * For functional programming, the {@link #forEach(Consumer)} method and the {@link #timedForEach(Consumer, long)}
 * method can be used to perform actions on each generated element. Note that these methods will
 * also loop indefinitely. To use them in a thread, wrap the action in a {@link Runnable} and
 * run it in a dedicated or external {@link Thread} like so:
 * <pre>{@code
 *     Generatable<Integer> intGen = ...; // some generator that produces integers
 *     Runnable task = () -> intGen.forEach(i -> {
 *         System.out.println(i); // Or do something else with the generated integer
 *     });
 *     Thread thread = new Thread(task);
 *     thread.start();
 *     // Do other things in the main thread
 *     // To stop the generation, interrupt the thread
 *     thread.interrupt();
 * }</pre>
 * <p>
 * Few static methods are provided to create common generators, such as:
 * <ul>
 *     <li>{@link #of(Iterable)}: Create a generatable that cycles through the given iterable.</li>
 *     <li>{@link #randomAccess(Iterable)}: Create a generatable that randomly accesses the given iterable.</li>
 *     <li>{@link #of(Object...)}: Create a generatable that cycles through the given elements.</li>
 *     <li>{@link #randomAccess(Object...)}: Create a generatable that randomly accesses the given elements.</li>
 *     <li>{@link #of(Stream)}: Create a generatable that cycles through the given stream. You should not expect to find a {@code #randomAccess}
 *         stream method, as streams are not random access by nature. </li>
 *     <li>{@link #generate(java.util.function.Supplier)}: Create a generatable that generates elements using the given supplier.</li>
 * </ul>
 * And the random generators supported by {@link Random}, such as {@link #randomInt()}, {@link #randomLong()}, {@link #randomDouble()}, etc.
 *
 * @param <T> The type of elements generated
 */
public interface Generatable<T> extends Iterable<T> {
    /**
     * {@inheritDoc}
     * @implNote return the generator as iterator, will loop forever.
     * @return the generator as iterator
     */
    default Iterator<T> iterator() {
        return generator();
    }
    /**
     * Return a generator that will loop forever.
     * @return a generator that will loop forever
     */
    Generator<T> generator();
    /**
     * Performs the given action for each element generated by the {@code Generatable}.
     * Actions are performed in the order of generation. Exceptions thrown by the action
     * are relayed to the caller.
     * <p>
     * Generated elements are for one-time use only and actions are not supposed to modify
     * the underlying generator. The behavior of this method is unspecified if the action
     * performs side-effects that modify the underlying source of elements, unless an
     * overriding class has specified a concurrent modification policy.
     * <p>
     * Since this is an infinite loop and this method normally does not terminate, it is
     * possible to wrap the action in a {@link Runnable} with a dedicated or external
     * {@link Thread} to manage generation. If action should be timed, use
     * {@link #timedForEach(Consumer, long)} instead.
     *
     * @implNote perform the given action for each element of the generator, will loop forever.
     * @param action The action to perform for each element
     */
    default void forEach(Consumer<? super T> action) {
        Iterable.super.forEach(action);
    }
    /**
     * Performs the given action for each element generated by the {@code Generatable},
     * pausing for the specified interval between each action. Actions are performed in
     * the order of generation. Exceptions thrown by the action are relayed to the caller.
     * <p>
     * Generated elements are for one-time use only and actions are not supposed to modify
     * the underlying generator. The behavior of this method is unspecified if the action
     * performs side-effects that modify the underlying source of elements, unless an
     * overriding class has specified a concurrent modification policy.
     * <p>
     * Since this is an infinite loop and this method normally does not terminate, it is
     * possible to wrap the action in a {@link Runnable} with a dedicated or external
     * {@link Thread} to manage generation.
     *
     * @implNote perform the given action for each element of the generator, will loop forever,
     *           pausing for the specified interval between each action.
     * @param action The action to perform for each element
     * @param intervalMillis The interval in milliseconds to pause between each action
     */
    default void timedForEach(Consumer<? super T> action, long intervalMillis) {
        Generator<T> gen = generator();
        while (true) {
            action.accept(gen.next());
            try {
                Thread.sleep(intervalMillis);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    /**
     * Create a stream from the generator. The stream is infinite and will not terminate.
     * @implNote create a stream from the generator, the stream is infinite and will not terminate.
     * @return a stream from the generator
     */
    default Stream<T> stream() {
        Generator<T> gen = this.generator();
        return Stream.generate(gen::next);
    }

    // Static
    /**
     * Create a generatable that cycles through the given iterable.
     * @param iterable The iterable to cycle through.
     * @param <E> The type of the elements in the iterable.
     * @return A generatable that cycles through the given iterable.
     */
    static <E> Generatable<E> of (Iterable<E> iterable){
        final Iterator<E>[] it = new Iterator[]{iterable.iterator()};
        return () -> () -> {
            if (!it[0].hasNext()) it[0] = iterable.iterator();
            return it[0].next();
        };
    }
    /**
     * Create a generatable that cycles through the given stream.
     * Note that the stream will be consumed and cannot be reused.
     * <p>
     * If the stream is finite, the generatable will throw an {@link IllegalStateException}
     * when the stream is exhausted.
     *
     * @implNote if the stream is finite, the generatable will throw an {@link IllegalStateException}
     *           when the stream is exhausted.
     * @param stream The stream to cycle through.
     * @param <E> The type of the elements in the stream.
     * @return A generatable that cycles through the given stream.
     */
    static <E> Generatable<E> of (Stream<E> stream){
        Iterator<E> it = stream.iterator();
        return () -> () -> {
            if (!it.hasNext()) throw new IllegalStateException("Stream has no more elements");
            return it.next();
        };
    }
    /**
     * Create a generatable that randomly accesses the given iterable.
     * @param iterable The iterable to randomly access.
     * @param <E> The type of the elements in the iterable.
     * @return A generatable that randomly accesses the given iterable.
     */
    @SuppressWarnings("unchecked")
    static <E> Generatable<E> randomAccess(Iterable<E> iterable){
        // If this is random access, we can optimize the generator
        Random rand = new Random();
        if (iterable instanceof RandomAccess && iterable instanceof Collection<?> collection) {
            // If this is a list, we can get the size and access elements by index
            if (iterable instanceof java.util.List<?> list) {
                return () -> () -> (E) list.get(rand.nextInt(collection.size()));
            }
            // Otherwise convert to array and access by index
            return () -> () -> {
                E[] array = (E[]) collection.toArray(); // Always copy in case changed
                return array[rand.nextInt(array.length)];
            };
        }
        return () -> () -> {
            // Get iterator and go to random index
            Iterator<E> it = iterable.iterator();
            // Determine size of iterable
            int size = 0;
            while (it.hasNext()) {
                it.next();
                size++;
            }
            it = iterable.iterator();
            // Get random index
            int index = rand.nextInt(size);
            for (int i = 0; i < index; i++) {
                it.next();
            }
            return it.next();
        };
    }
    /**
     * Create a generatable that cycles through the given elements.
     * @param elements The elements to cycle through.
     * @param <E> The type of the elements.
     * @return A generatable that cycles through the given elements.
     */
    @SafeVarargs
    static <E> Generatable<E> of (E... elements){
        return () -> new Generator<>() {
            int index = 0;
            @Override
            public E next() {
                if (index >= elements.length) index = 0;
                return elements[index++];
            }
        };
    }
    /**
     * Create a generatable that randomly accesses the given elements.
     * @param elements The elements to randomly access.
     * @param <E> The type of the elements.
     * @return A generatable that randomly accesses the given elements.
     */
    @SafeVarargs
    static <E> Generatable<E> randomAccess(E... elements){
        Random rand = new Random();
        return () -> () -> elements[rand.nextInt(elements.length)];
    }
    /**
     * Create a generatable that generates elements using the given supplier.
     * @param supplier The supplier to use to generate elements.
     * @param <E> The type of the elements.
     * @return A generatable that generates elements using the given supplier.
     */
    static <E> Generatable<E> generate(java.util.function.Supplier<E> supplier){
        return () -> supplier::get;
    }
    /**
     * Create a generatable that generates random booleans uniformly distributed.
     * @return A generatable that generates random booleans.
     */
    static Generatable<Boolean> randomBoolean(){
        Random rand = new Random();
        return () -> () -> {
            // Just use random int and check if even or odd
            return rand.nextInt() % 2 == 0;
        };
    }
    /**
     * Create a generatable that generates random integers uniformly distributed.
     * @return A generatable that generates random integers.
     */
    static Generatable<Integer> randomInt(){
        Random rand = new Random();
        return () -> rand::nextInt;
    }
    /**
     * Create a generatable that generates random integers between the given min and max (inclusive).
     * @param min The minimum value (inclusive).
     * @param max The maximum value (exclusive).
     * @return A generatable that generates random integers between the given min and max.
     */
    static Generatable<Integer> randomInt(int min, int max){
        Random rand = new Random();
        return () -> () -> rand.nextInt(min, max);
    }
    /**
     * Create a generatable that generates random longs uniformly distributed.
     * @return A generatable that generates random longs.
     */
    static Generatable<Long> randomLong(){
        Random rand = new Random();
        return () -> () -> {
            // To mitigate the bias of nextLong(), we combine two nextInt() calls
            long high = ((long) rand.nextInt()) << 32;
            long low = ((long) rand.nextInt()) & 0xFFFFFFFFL;
            return high | low;
        };
    }
    /**
     * Create a generatable that generates random longs between the given min and max (inclusive).
     * @param min The minimum value (inclusive).
     * @param max The maximum value (exclusive).
     * @return A generatable that generates random longs between the given min and max.
     */
    static Generatable<Long> randomLong(long min, long max){
        Random rand = new Random();
        return () -> () -> {
            // To mitigate the bias of nextLong(), we combine two nextInt() calls
            long range = max - min;
            long high = ((long) rand.nextInt()) << 32;
            long low = ((long) rand.nextInt()) & 0xFFFFFFFFL;
            long randomLong = (high | low) % range;
            return randomLong + min;
        };
    }
    /**
     * Create a generatable that generates random characters between 'a' and 'z'.
     * @return A generatable that generates random characters between 'a' and 'z'.
     */
    static Generatable<Character> randomChar(){
        Random rand = new Random();
        return () -> () -> (char) (rand.nextInt(26) + 'a');
    }
    /**
     * Create a generatable that generates random floats between 0.0 and 1.0.
     * @return A generatable that generates random floats between 0.0 and 1.0.
     */
    static Generatable<Float> randomFloat(){
        Random rand = new Random();
        return () -> rand::nextFloat;
    }
    /**
     * Create a generatable that generates random floats between the given min and max (inclusive).
     * @param min The minimum value (inclusive).
     * @param max The maximum value (exclusive).
     * @return A generatable that generates random floats between the given min and max.
     */
    static Generatable<Float> randomFloat(float min, float max){
        Random rand = new Random();
        return () -> () -> (float)(rand.nextDouble() * (max - min) + min); // Double used for better precision
    }
    /**
     * Create a generatable that generates random doubles between 0.0 and 1.0.
     * <p>
     * This is similar to a generator that always calls {@link Math#random()}.
     * @return A generatable that generates random doubles between 0.0 and 1.0.
     */
    static Generatable<Double> random() {
        Random rand = new Random();
        return () -> rand::nextDouble;
    }
    /**
     * Create a generatable that generates random doubles between 0.0 and 1.0.
     * @return A generatable that generates random doubles between 0.0 and 1.0.
     */
    static Generatable<Double> randomDouble(){
        Random rand = new Random();
        return () -> rand::nextDouble;
    }
    /**
     * Create a generatable that generates random doubles between the given min and max (inclusive).
     * @param min The minimum value (inclusive).
     * @param max The maximum value (exclusive).
     * @return A generatable that generates random doubles between the given min and max.
     */
    static Generatable<Double> randomDouble(double min, double max){
        Random rand = new Random();
        return () -> () -> rand.nextDouble() * (max - min) + min;
    }
}
